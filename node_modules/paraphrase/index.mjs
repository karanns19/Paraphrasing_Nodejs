// src/notate/index.ts
function notate(source, string = "") {
  if (typeof string !== "string") {
    throw new TypeError(
      `Expected notation query to be a string, instead got ${typeof string} (${string})`
    );
  }
  return string.split(".").reduce(
    (previous, current) => typeof previous === "object" && previous ? previous[current] : previous,
    source
  );
}

// src/isObject/index.ts
var isObject = (obj) => `${obj}` === "[object Object]";

// src/flavours/index.ts
var flavours = {
  /**
   * Template: 'Hello, ${name}'
   */
  dollar: /\${([^{}]*)}/gm,
  /**
   * Template: 'Hello, {{name}}'
   */
  double: /{{([^{}]*)}}/gm,
  /**
   * Template: 'Hello, {name}'
   */
  single: /{([^{}]*)}/gm,
  /**
   * Template: 'Hello, #{name}'
   */
  hash: /#{([^{}]*)}/gm,
  /**
   * Template: 'Hello, %{name}'
   */
  percent: /%{([^{}]*)}/gm
};

// src/index.ts
var VALID_RESULT_TYPES = Object.seal([
  "string",
  "number"
]);
function paraphrase(...args) {
  const options = {
    recursive: true,
    resolve: true,
    clean: false
  };
  if (args.length && isObject(args[args.length - 1])) {
    Object.assign(options, args.pop());
  }
  const patterns = args.flat().filter((arg) => arg instanceof RegExp);
  Object.freeze(patterns);
  function phraser(string = "", data, ...replacements) {
    if (typeof string !== "string") {
      throw new TypeError(
        `paraphrase expects first argument to be a string, got a ${typeof string} (${string})`
      );
    }
    if (!data) {
      return string;
    }
    if (VALID_RESULT_TYPES.includes(typeof data)) {
      data = [data, ...replacements];
    }
    function replace(haystack, needle) {
      const replacement = options.resolve ? notate(data, needle.trim()) : data[needle.trim()];
      return VALID_RESULT_TYPES.includes(typeof replacement) ? replacement : options.clean ? "" : haystack;
    }
    const result = patterns.reduce(
      (string2, pattern) => string2.replace(pattern, replace),
      string
    );
    return !options.recursive || string === result ? result : phraser(result, data, ...replacements);
  }
  Object.defineProperty(phraser, "patterns", {
    get: () => patterns
  });
  return phraser;
}
var dollar = paraphrase(flavours.dollar);
var double = paraphrase(flavours.double);
var single = paraphrase(flavours.single);
var percent = paraphrase(flavours.percent);
var hash = paraphrase(flavours.hash);
var loose = paraphrase(
  flavours.dollar,
  flavours.double,
  flavours.percent,
  flavours.hash,
  flavours.single
);
export {
  dollar,
  double,
  hash,
  loose,
  paraphrase,
  percent,
  single
};
//# sourceMappingURL=index.mjs.map
