{
  "version": 3,
  "sources": ["src/notate/index.ts", "src/isObject/index.ts", "src/flavours/index.ts", "src/index.ts"],
  "sourcesContent": ["/**\n * Resolve dot notation strings\n *\n * @param  {any} context Object to start notation search on (defaults to global scope)\n * @param  {string} [string=''] Dot notation representation\n * @return {any} Whatever it finds / undefined\n *\n * @example\n * const obj = {\n *   top_level: {\n *     nested: {\n *       value: 'My Value'\n *     }\n *   }\n * };\n *\n * notate(obj, 'top_level.nested.value');\n * // 'My Value'\n *\n * notate(obj, 'top_level.missing.value');\n * // undefined\n */\nexport function notate(source: any, string: string = \"\"): any {\n  if (typeof string !== \"string\") {\n    throw new TypeError(\n      `Expected notation query to be a string, instead got ${typeof string} (${string})`\n    );\n  }\n  return string\n    .split(\".\")\n    .reduce(\n      (previous, current) =>\n        typeof previous === \"object\" && previous ? previous[current] : previous,\n      source\n    );\n}\n", "/**\n * Is this a basic object?\n * @param  {any} obj Target to test\n * @return {boolean} true if object\n */\nexport const isObject = (obj: any): boolean => `${obj}` === \"[object Object]\";\n", "export const flavours: Record<string, RegExp> = {\n  /**\n   * Template: 'Hello, ${name}'\n   */\n  dollar: /\\${([^{}]*)}/gm,\n  /**\n   * Template: 'Hello, {{name}}'\n   */\n  double: /{{([^{}]*)}}/gm,\n  /**\n   * Template: 'Hello, {name}'\n   */\n  single: /{([^{}]*)}/gm,\n  /**\n   * Template: 'Hello, #{name}'\n   */\n  hash: /#{([^{}]*)}/gm,\n  /**\n   * Template: 'Hello, %{name}'\n   */\n  percent: /%{([^{}]*)}/gm,\n};\n", "import { notate } from \"./notate/index\";\nimport { isObject } from \"./isObject/index\";\nimport { flavours } from \"./flavours/index\";\n\n/**\n * Valid types of results for the interpolated string\n */\nconst VALID_RESULT_TYPES: [\"string\", \"number\"] = Object.seal([\n  \"string\",\n  \"number\",\n]);\n\ninterface IParaphraseOptions {\n  /**\n   * Should continue to resolve result string until replacements have been exhausted\n   */\n  recursive?: boolean;\n  /**\n   * Should resolve dot notation within template\n   */\n  resolve?: boolean;\n  /**\n   * Should remove unmatched template instances\n   */\n  clean?: boolean;\n}\n\ninterface Phraser {\n  (\n    /**\n     * Template string to parse\n     */\n    string: string | undefined,\n    /**\n     * Data to use for interpolation, preferrably an object, but an array will work too, and a primitive values will be treated as an array of \"...rest\" arguments\n     */\n    ...data: (Record<string, any> | any)[]\n  ): string;\n  patterns: RegExp[];\n}\n\n/**\n * Create new paraphrase method instance\n * @param  {...RegExp[]} replacers[] One or more patterns to use for string replacement\n * @param  {IParaphraseOptions} [options] The last argument can be an options object\n * @returns {Phraser} phraser function instance\n *\n * @example const phraser = paraphrase(/\\${([^{}]*)}/gm);\n *\n * phraser('Hello, ${name}', {name: 'Martin'})\n */\nexport function paraphrase(\n  ...args: (RegExp | RegExp[] | IParaphraseOptions)[]\n): Phraser {\n  const options: IParaphraseOptions = {\n    recursive: true,\n    resolve: true,\n    clean: false,\n  };\n  if (args.length && isObject(args[args.length - 1])) {\n    Object.assign(options, args.pop() as IParaphraseOptions);\n  }\n  const patterns = args.flat().filter((arg) => arg instanceof RegExp);\n\n  Object.freeze(patterns);\n\n  /**\n   * phraser description\n   * @param  {string}                 string       Template\n   * @param  {Object|(string|number)} data         Data for filling\n   * @param  {...(string|number)}     replacements Replacement for filling\n   * @return {string}                              Result\n   */\n  function phraser(\n    string: string = \"\",\n    data: string | number | Record<string, any>,\n    ...replacements: (string | number)[]\n  ): string {\n    if (typeof string !== \"string\") {\n      throw new TypeError(\n        `paraphrase expects first argument to be a string, got a ${typeof string} (${string})`\n      );\n    }\n\n    if (!data) {\n      return string;\n    }\n\n    if (VALID_RESULT_TYPES.includes(typeof data as any)) {\n      data = [data, ...replacements];\n    }\n\n    /**\n     * Replace method build with internal reference to the passed in data structure\n     * @param  {string} haystack The full string match\n     * @param  {string} needle   The content to identify as data member\n     * @return {string}         Found value\n     */\n    function replace(haystack: string, needle: string): string {\n      const replacement = options.resolve\n        ? notate(data, needle.trim())\n        : data[needle.trim()];\n\n      return VALID_RESULT_TYPES.includes(typeof replacement as any)\n        ? replacement\n        : options.clean\n        ? \"\"\n        : haystack;\n    }\n\n    const result = (patterns as RegExp[]).reduce(\n      (string: string, pattern: RegExp): string =>\n        string.replace(pattern, replace),\n      string\n    );\n\n    return !options.recursive || string === result\n      ? result\n      : phraser(result, data, ...replacements);\n  }\n\n  Object.defineProperty(phraser, \"patterns\", {\n    get: () => patterns,\n  });\n\n  return phraser as Phraser;\n}\n\nexport const dollar = paraphrase(flavours.dollar);\nexport const double = paraphrase(flavours.double);\nexport const single = paraphrase(flavours.single);\nexport const percent = paraphrase(flavours.percent);\nexport const hash = paraphrase(flavours.hash);\nexport const loose = paraphrase(\n  flavours.dollar,\n  flavours.double,\n  flavours.percent,\n  flavours.hash,\n  flavours.single\n);\n"],
  "mappings": ";AAsBO,SAAS,OAAO,QAAa,SAAiB,IAAS;AAC5D,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI;AAAA,MACR,uDAAuD,OAAO,WAAW;AAAA,IAC3E;AAAA,EACF;AACA,SAAO,OACJ,MAAM,GAAG,EACT;AAAA,IACC,CAAC,UAAU,YACT,OAAO,aAAa,YAAY,WAAW,SAAS,OAAO,IAAI;AAAA,IACjE;AAAA,EACF;AACJ;;;AC9BO,IAAM,WAAW,CAAC,QAAsB,GAAG,UAAU;;;ACLrD,IAAM,WAAmC;AAAA;AAAA;AAAA;AAAA,EAI9C,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,SAAS;AACX;;;ACdA,IAAM,qBAA2C,OAAO,KAAK;AAAA,EAC3D;AAAA,EACA;AACF,CAAC;AAyCM,SAAS,cACX,MACM;AACT,QAAM,UAA8B;AAAA,IAClC,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,EACT;AACA,MAAI,KAAK,UAAU,SAAS,KAAK,KAAK,SAAS,CAAC,CAAC,GAAG;AAClD,WAAO,OAAO,SAAS,KAAK,IAAI,CAAuB;AAAA,EACzD;AACA,QAAM,WAAW,KAAK,KAAK,EAAE,OAAO,CAAC,QAAQ,eAAe,MAAM;AAElE,SAAO,OAAO,QAAQ;AAStB,WAAS,QACP,SAAiB,IACjB,SACG,cACK;AACR,QAAI,OAAO,WAAW,UAAU;AAC9B,YAAM,IAAI;AAAA,QACR,2DAA2D,OAAO,WAAW;AAAA,MAC/E;AAAA,IACF;AAEA,QAAI,CAAC,MAAM;AACT,aAAO;AAAA,IACT;AAEA,QAAI,mBAAmB,SAAS,OAAO,IAAW,GAAG;AACnD,aAAO,CAAC,MAAM,GAAG,YAAY;AAAA,IAC/B;AAQA,aAAS,QAAQ,UAAkB,QAAwB;AACzD,YAAM,cAAc,QAAQ,UACxB,OAAO,MAAM,OAAO,KAAK,CAAC,IAC1B,KAAK,OAAO,KAAK,CAAC;AAEtB,aAAO,mBAAmB,SAAS,OAAO,WAAkB,IACxD,cACA,QAAQ,QACR,KACA;AAAA,IACN;AAEA,UAAM,SAAU,SAAsB;AAAA,MACpC,CAACA,SAAgB,YACfA,QAAO,QAAQ,SAAS,OAAO;AAAA,MACjC;AAAA,IACF;AAEA,WAAO,CAAC,QAAQ,aAAa,WAAW,SACpC,SACA,QAAQ,QAAQ,MAAM,GAAG,YAAY;AAAA,EAC3C;AAEA,SAAO,eAAe,SAAS,YAAY;AAAA,IACzC,KAAK,MAAM;AAAA,EACb,CAAC;AAED,SAAO;AACT;AAEO,IAAM,SAAS,WAAW,SAAS,MAAM;AACzC,IAAM,SAAS,WAAW,SAAS,MAAM;AACzC,IAAM,SAAS,WAAW,SAAS,MAAM;AACzC,IAAM,UAAU,WAAW,SAAS,OAAO;AAC3C,IAAM,OAAO,WAAW,SAAS,IAAI;AACrC,IAAM,QAAQ;AAAA,EACnB,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AACX;",
  "names": ["string"]
}
