var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  dollar: () => dollar,
  double: () => double,
  hash: () => hash,
  loose: () => loose,
  paraphrase: () => paraphrase,
  percent: () => percent,
  single: () => single
});
module.exports = __toCommonJS(src_exports);

// src/notate/index.ts
function notate(source, string = "") {
  if (typeof string !== "string") {
    throw new TypeError(
      `Expected notation query to be a string, instead got ${typeof string} (${string})`
    );
  }
  return string.split(".").reduce(
    (previous, current) => typeof previous === "object" && previous ? previous[current] : previous,
    source
  );
}

// src/isObject/index.ts
var isObject = (obj) => `${obj}` === "[object Object]";

// src/flavours/index.ts
var flavours = {
  /**
   * Template: 'Hello, ${name}'
   */
  dollar: /\${([^{}]*)}/gm,
  /**
   * Template: 'Hello, {{name}}'
   */
  double: /{{([^{}]*)}}/gm,
  /**
   * Template: 'Hello, {name}'
   */
  single: /{([^{}]*)}/gm,
  /**
   * Template: 'Hello, #{name}'
   */
  hash: /#{([^{}]*)}/gm,
  /**
   * Template: 'Hello, %{name}'
   */
  percent: /%{([^{}]*)}/gm
};

// src/index.ts
var VALID_RESULT_TYPES = Object.seal([
  "string",
  "number"
]);
function paraphrase(...args) {
  const options = {
    recursive: true,
    resolve: true,
    clean: false
  };
  if (args.length && isObject(args[args.length - 1])) {
    Object.assign(options, args.pop());
  }
  const patterns = args.flat().filter((arg) => arg instanceof RegExp);
  Object.freeze(patterns);
  function phraser(string = "", data, ...replacements) {
    if (typeof string !== "string") {
      throw new TypeError(
        `paraphrase expects first argument to be a string, got a ${typeof string} (${string})`
      );
    }
    if (!data) {
      return string;
    }
    if (VALID_RESULT_TYPES.includes(typeof data)) {
      data = [data, ...replacements];
    }
    function replace(haystack, needle) {
      const replacement = options.resolve ? notate(data, needle.trim()) : data[needle.trim()];
      return VALID_RESULT_TYPES.includes(typeof replacement) ? replacement : options.clean ? "" : haystack;
    }
    const result = patterns.reduce(
      (string2, pattern) => string2.replace(pattern, replace),
      string
    );
    return !options.recursive || string === result ? result : phraser(result, data, ...replacements);
  }
  Object.defineProperty(phraser, "patterns", {
    get: () => patterns
  });
  return phraser;
}
var dollar = paraphrase(flavours.dollar);
var double = paraphrase(flavours.double);
var single = paraphrase(flavours.single);
var percent = paraphrase(flavours.percent);
var hash = paraphrase(flavours.hash);
var loose = paraphrase(
  flavours.dollar,
  flavours.double,
  flavours.percent,
  flavours.hash,
  flavours.single
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  dollar,
  double,
  hash,
  loose,
  paraphrase,
  percent,
  single
});
//# sourceMappingURL=index.js.map
